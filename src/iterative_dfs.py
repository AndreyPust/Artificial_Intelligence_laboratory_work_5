#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import math
import sys
from abc import ABC, abstractmethod


class Problem(ABC):
    """
    Абстрактный класс для формальной постановки задачи.
    Новый домен (конкретная задача) должен специализировать этот класс,
    переопределяя методы actions и result, а при необходимости
    action_cost, h и is_goal.
    """

    def __init__(self, initial=None, goal=None, **kwargs):
        self.initial = initial
        self.goal = goal
        # Сохраняем все остальные переданные параметры (при желании).
        for k, v in kwargs.items():
            setattr(self, k, v)

    @abstractmethod
    def actions(self, state):
        """
        Вернуть доступные действия (операторы) из данного состояния.
        """
        pass

    @abstractmethod
    def result(self, state, action):
        """
        Вернуть результат применения действия к состоянию.
        """
        pass

    def is_goal(self, state):
        """
        Проверка, является ли состояние целевым.
        """
        return state == self.goal

    def action_cost(self, s, a, s1):
        """
        Возвращает стоимость применения действия a, переводящего s в s1 (по умолчанию 1).
        """
        return 1

    def h(self, node):
        """
        Эвристическая функция; по умолчанию = 0.
        """
        return 0

    def __str__(self):
        return f"{type(self).__name__}({self.initial!r}, {self.goal!r})"


class Node:
    """Узел в дереве поиска."""

    def __init__(self, state, parent=None, action=None, path_cost=0.0):
        self.state = state  # Текущее состояние
        self.parent = parent  # Родительский узел
        self.action = action  # Действие, которое привело к этому узлу
        self.path_cost = path_cost  # Стоимость пути

    def __repr__(self):
        return f"<Node {self.state}>"

    def __lt__(self, other):
        return self.path_cost < other.path_cost

    def __len__(self):
        if self.parent is None:
            return 0
        else:
            return 1 + len(self.parent)


failure = Node("failure", path_cost=math.inf)
cutoff = Node("cutoff", path_cost=math.inf)


def expand(problem, node):
    """
    Генерируем (расширяем) дочерние узлы, применяя все действия к node.state.
    """
    s = node.state
    for action in problem.actions(s):
        s1 = problem.result(s, action)
        cost = node.path_cost + problem.action_cost(s, action, s1)
        yield Node(state=s1, parent=node, action=action, path_cost=cost)


def path_actions(node):
    """
    Восстанавливаем последовательность действий от корня до данного узла.
    """
    if node.parent is None:
        return []
    return path_actions(node.parent) + [node.action]


def path_states(node):
    """
    Восстанавливаем последовательность состояний (городов)
    от корня до данного узла.
    """
    if node.parent is None:
        return [node.state]
    return path_states(node.parent) + [node.state]


def is_cycle(node):
    """
    Проверяем, не образуется ли цикл (повтор состояния) при движении.
    Если состояние node.state уже встречалось в цепочке родительских узлов,
    значит это цикл.
    """
    s = node.state
    p = node.parent
    while p is not None:
        if p.state == s:
            return True
        p = p.parent
    return False


class LIFOQueue(list):
    """
    Реализация стека в виде списка
    """

    pass


def depth_limited_search(problem, limit):
    """
    Реализация алгоритма поиска с ограничением глубины.
    Пока стек не пуст извлекаем вершину. Если это цель, возвращаем.
    Иначе, если глубина >= limit, запоминаем result = cutoff.
    Если нет цикла, расширяем и складываем потомков в стек.
    Если цель не найдена, то возврат failure.
    """

    frontier = LIFOQueue([Node(problem.initial)])
    result = failure

    while frontier:
        node = frontier.pop()

        # Проверка на цель
        if problem.is_goal(node.state):
            return node

        # Проверка на лимит глубины
        if len(node) >= limit:
            result = cutoff
        elif not is_cycle(node):
            # Расширяем
            for child in expand(problem, node):
                frontier.append(child)

    return result


def iterative_deepening_search(problem):
    """
    Выполняем поиск с ограничением глубины, с возрастающим лимитом.
    Начинаем с limit=1 и до бесконечности.
    """
    for limit in range(1, sys.maxsize):
        result = depth_limited_search(problem, limit)
        if result != cutoff:
            return result


class MapProblem(Problem):
    """
    Дочерний класс для постановки задачи:
    Найти путь из одного города в другой по графу.
    """

    def __init__(self, initial, goal, graph):
        super().__init__(initial=initial, goal=goal)
        self.graph = graph

    def actions(self, state):
        """Все соседние города из state."""
        return list(self.graph[state].keys())

    def result(self, state, action):
        """Перейти в город 'action'."""
        return action

    def action_cost(self, s, a, s1):
        """Стоимость (расстояние) из s в s1."""
        return self.graph[s][s1]


def main():
    """
    Главная функция программы.
    """

    # Граф городов Австралии
    graph = {
        "Буриндал": {"Уоррен": 271, "Нинган": 156, "Кобар": 204},
        "Уоррен": {"Буриндал": 271, "Нинган": 78, "Гилгандра": 103, "Нарромин": 86},
        "Нинган": {"Буриндал": 156, "Канбелего": 86, "Уоррен": 78, "Бобада": 150, "Наймаджи": 122},
        "Кобар": {"Буриндал": 204, "Канбелего": 50, "Наймаджи": 97.5, "Гулгуния": 110},
        "Канбелего": {"Кобар": 50, "Наймаджи": 61, "Нинган": 86},
        "Наймаджи": {"Канбелего": 61, "Нинган": 122, "Бобада": 150, "Кобар": 97.5, "Гулгуния": 46},
        "Гулгуния": {"Кобар": 110, "Наймаджи": 46, "Матакана": 70},
        "Матакана": {"Гулгуния": 70, "Лейк_Каргеллиго": 99},
        "Бобада": {"Наймаджи": 150, "Нинган": 150, "Нарромин": 203, "Медроз": 50},
        "Нарромин": {"Уоррен": 86, "Бобада": 203, "Пикхилл": 57, "Даббо": 41},
        "Пикхилл": {"Нарромин": 57, "Даббо": 70, "Веллингтон": 109, "Медроз": 172, "Кондоболин": 147, "Паркс": 55},
        "Даббо": {"Нарромин": 41, "Гилгандра": 66, "Данду": 88, "Веллингтон": 49, "Пикхилл": 70},
        "Гилгандра": {"Уоррен": 103, "Даббо": 66, "Тураина": 49, "Данду": 92},
        "Данду": {"Даббо": 88, "Маджи": 80, "Гилгандра": 92, "Кула": 47},
        "Медроз": {"Бобада": 50, "Кондоболин": 56, "Пикхилл": 172},
        "Кондоболин": {
            "Медроз": 56,
            "Паркс": 104,
            "Гренфелл": 164,
            "Уэст_Уайалонг": 104,
            "Лейк_Каргеллиго": 94,
            "Пикхилл": 147,
        },
        "Паркс": {"Пикхилл": 55, "Кондоболин": 104, "Гренфелл": 100, "Ориндж": 104},
        "Гренфелл": {"Паркс": 100, "Ориндж": 139, "Кора": 58, "Янг": 53, "Кондоболин": 164, "Уэст_Уайалонг": 113},
        "Ориндж": {"Кора": 104, "Паркс": 104, "Веллингтон": 105, "Батерст": 55, "Гренфелл": 139},
        "Веллингтон": {"Маджи": 114, "Пикхилл": 109, "Даббо": 49, "Ориндж": 105},
        "Маджи": {"Веллингтон": 114, "Данду": 80, "Меррива": 167, "Сеснок": 255, "Батерст": 134, "Литго": 126},
        "Батерст": {"Литго": 62, "Кора": 106, "Круквелл": 155, "Ориндж": 55, "Маджи": 134},
        "Литго": {"Батерст": 62, "Кетумба": 41, "Маджи": 126, "Госфорд": 174},
        "Кора": {"Гренфелл": 58, "Ориндж": 104, "Батерст": 106, "Бурова": 78},
        "Бурова": {"Янг": 47, "Кора": 78, "Круквелл": 85, "Гоулберн": 140},
        "Круквелл": {"Батерст": 155, "Кетумба": 229, "Гоулберн": 43, "Бурова": 85},
        "Гоулберн": {"Бурова": 140, "Круквелл": 43, "Нора": 125, "Боурал": 83},
        "Нора": {"Гоулберн": 125, "Боурал": 66, "Киама": 55},
        "Боурал": {"Нора": 66, "Киама": 77, "Вуллонгонг": 82, "Камден": 68, "Гоулберн": 83},
        "Киама": {"Нора": 55, "Вуллонгонг": 43, "Боурал": 77},
        "Вуллонгонг": {"Киама": 43, "Боурал": 82, "Камден": 72, "Сидней": 80},
        "Камден": {"Боурал": 68, "Вуллонгонг": 72, "Кетумба": 96, "Сидней": 75},
        "Сидней": {"Вуллонгонг": 80, "Камден": 75, "Кетумба": 106, "Вои_вои": 81},
        "Кетумба": {"Литго": 41, "Сидней": 106, "Камден": 96, "Вои_вои": 156, "Круквелл": 229},
        "Вои_вои": {"Сидней": 81, "Кетумба": 156, "Госфорд": 16},
        "Госфорд": {"Вои_вои": 16, "Ньюкасл": 84, "Сеснок": 85, "Литго": 174},
        "Ньюкасл": {"Госфорд": 84, "Сеснок": 45, "Мейтленд": 34, "Дангог": 104},
        "Сеснок": {"Госфорд": 85, "Ньюкасл": 45, "Меррива": 159, "Синглтон": 53, "Маджи": 255},
        "Мейтленд": {"Ньюкасл": 34, "Дангог": 53, "Синглтон": 48},
        "Дангог": {"Ньюкасл": 104, "Мейтленд": 53},
        "Синглтон": {"Сеснок": 53, "Мейтленд": 48, "Маселбрук": 49},
        "Маселбрук": {"Синглтон": 49, "Меррива": 77},
        "Меррива": {"Сеснок": 159, "Маселбрук": 77, "Кула": 81, "Маджи": 167},
        "Кула": {"Меррива": 81, "Данду": 47, "Тураина": 132},
        "Тураина": {"Кула": 132, "Гилгандра": 49},
        "Лейк_Каргеллиго": {"Матакана": 99, "Кондоболин": 94, "Уэст_Уайалонг": 119},
        "Уэст_Уайалонг": {"Лейк_Каргеллиго": 119, "Кондоболин": 104, "Гренфелл": 113, "Янг": 150},
        "Янг": {"Уэст_Уайалонг": 150, "Гренфелл": 53, "Бурова": 47},
    }

    # Создаём задачу
    problem = MapProblem(initial="Буриндал", goal="Сидней", graph=graph)

    solution_node = iterative_deepening_search(problem)

    if solution_node is None or solution_node is failure:
        print("Путь не найден!")
    elif solution_node is cutoff:
        print("Поиск прерван (cutoff).")
    else:
        # Восстанавливаем маршрут
        route = path_states(solution_node)
        print("Найден маршрут:", " -> ".join(route))
        print("Суммарная стоимость:", solution_node.path_cost)


if __name__ == "__main__":
    main()
